#!/usr/bin/env perl
use strict;
use warnings;
use LWP::Simple;
use Cwd 'chdir';
use File::Basename;
use File::Slurp 'read_file';

my $s;

print "// Generated by ".basename(__FILE__)."\n";

sub fmtcp {
  return sprintf("%x", hex($_[0]));
}

# ===============================================================================================

$s = LWP::Simple::get('http://www.unicode.org/Public/7.0.0/ucd/UnicodeData.txt') or die;
# $s = read_file('UnicodeData.txt');

my @whitespaceCodepoints = ();
my @controlCodepoints = ();

# See ftp://ftp.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.html
#
#  Example line: "0004;<control>;Cc;0;BN; ; ; ; ;N;END OF TRANSMISSION;  ;  ;  ; ..."
#  Field:            0;        1; 2;3; 4;5;6;7;8;9;                 10;11;12;13; ...
#
for (split /^/, $s) {
  my @entry = split(/;/, $_);

  my $codepoint = $entry[0];
  my $name = $entry[1];
  my $category = $entry[2];
  my $legacy_name = $entry[10];

  if ($category eq 'Zs') {
    push(@whitespaceCodepoints, "0x$codepoint // $name");
  } elsif ($category eq 'Cc') {
    if ($name eq '<control>') {
      $name = $legacy_name;
    }
    if ($name eq '') {
      push(@controlCodepoints, "0x$codepoint");
    } else {
      push(@controlCodepoints, "0x$codepoint // $name");
    }
  }
  # print @entry;
}


# ===============================================================================================

$s = LWP::Simple::get('http://www.unicode.org/Public/7.0.0/ucd/LineBreak.txt') or die;
# $s = read_file('LineBreak.txt');

my @linebreakCodepoints = ();

# Example line:  "003C..003E;AL     # Sm     [3] LESS-THAN SIGN..GREATER-THAN SIGN"

for (split /^/, $s) {
  # print $_;
  my @entry = split(/;/, $_);
  if ($#entry > 0) {
    my $codepoints = $entry[0];
    if ($entry[1] =~ m/^(\w+)\s+#\s+([^\s]+)\s+(?:\[\d+\])?\s*(.+)/) {
      my $type = $1;
      my $category = $2;
      my $name = $3;

      if ($type eq 'LF' || $type eq 'CR' || $type eq 'BK') {
        if ($codepoints =~ m/^([^\.]+)\.{2}([^\.]+)$/) {
          # Codepoint range
          my $i = hex($1);
          my $end = hex($2)+1;
          my @v = ();
          for (;$i != $end; $i++) {
            push(@v, "0x".sprintf("%x", $i));
          }
          push(@linebreakCodepoints, join(', ', @v)." // $name");
        } else {
          push(@linebreakCodepoints, "0x".fmtcp($codepoints)." // $name");
        }
      }
    # } else {
    #   print 'Did not match: ' . @entry . "\n";
    }
  }
}

# ===============================================================================================

print "const CharacterSet WhitespaceCharacterSet{\n   ";
print join("\n  ,", @whitespaceCodepoints);
print "\n};\n\n";

print "const CharacterSet LinebreakCharacterSet{\n   ";
print join("\n  ,", @linebreakCodepoints);
print "\n};\n\n";

print "const CharacterSet ControlCharacterSet{\n   ";
print join("\n  ,", @controlCodepoints);
print "\n};\n\n";

print "const CharacterSet WhitespaceLinebreakAndControlCharacterSet{\n  ";
print "// -- WhitespaceCharacterSet:\n   ";
print join("\n  ,", @whitespaceCodepoints);
print "\n  // -- LinebreakCharacterSet:\n  ,";
print join("\n  ,", @linebreakCodepoints);
print "\n  // -- ControlCharacterSet:\n  ,";
print join("\n  ,", @controlCodepoints);
print "\n};\n\n";

# ===============================================================================================

$s = LWP::Simple::get('http://www.unicode.org/Public/UNIDATA/CaseFolding.txt') or die;
# $s = read_file('CaseFolding.txt');

# Remove whole-line comments and empty lines
$s =~ s/^#.*\n//mg;
$s =~ s/^[\s\t ]*\n//mg;

# Remove full folds (we are performing simple folds aka point-to-point folds)
# Mappings that cause strings to grow in length. Multiple characters are separated by spaces.
$s =~ s/^.+ F; .+\n//mg;

# Remove special-case Turkic uppercase I and dotted uppercase I folding not used in other languages.
$s =~ s/^.+ T; .+\n//mg;

# Common and simple folds
my $s_constexpr = $s;
$s           =~ s/^(.+); [CS]; (.+); # (.+)\n/    case 0x$1: return 0x$2; \/\/ $3\n/gm;
$s_constexpr =~ s/^(.+); [CS]; (.+); # (.+)\n/    uc == 0x$1 ? 0x$2 : \/\/ $3\n/gm;

# Print results to stdout
print("u32 normalize(u32 uc) {\n");
print("  switch (uc) {\n");
print($s);
print("    default: return uc; // Not folded\n");
print("  }\n");
print("}\n");

# Constexpr version:
# print("\n");
# print("// Generated by ".basename(__FILE__)."\n");
# print("constexpr u32 toLowerCX(u32 uc) {\n");
# print("  return \n");
# print($s_constexpr);
# print("    uc; // Not folded\n");
# print("}\n");

